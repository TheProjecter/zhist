#!/usr/bin/python
# 
# Copyright (c) 2010 Edward Harvey
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import sys, os, getopt

def usage(subcommand=""):
    if subcommand == "":
        print """
usage: zhist subcommand [options] [args]
Type 'zhist help subcommand' for help on a specific subcommand.

Available subcommands:
   cp
   help
   locate
   ls
   rollback
   
"""
    elif subcommand == "cp":
        print """
usage: zhist cp [options] src@snapshot dst

Copies a file or directory from snapshot to a new name in the present filesystem.
src@snapshot
      Specifies the name of the file or directory, and snapshot. If src is a directory, 
      the copy will be recursive.
dst   
      Specifies the new name.  Cannot be omitted.  Use '.' to specify the current directory.
      If dst is an already existing directory, then an object having the same name
      as src will be created inside dst, mimicking the "normal" behavior of the
      operating system "cp" command. If dst already exists, zhist will abort,
      unless --force or --sure are specified.

Valid Options:
-f,--force
      If the destination already exists, clobber it.  This will be done "safe" meaning
      rename destination, write destination, and remove the temp object.  If there is a 
      failure to write destination, an attempt will be made to put things back the way
      they were before. 
-s,--sure
      If the destination already exists, clobber it, can't undo.  This implies --force 

"""
    elif subcommand == "locate":
        print """
usage: zhist locate filename[@snapshot]

Generates the absolute path(s) to the snapshot(s) of the specified filename.

"""
    elif subcommand == "ls":
        print """
usage: zhist ls filename

Generates a list of all the available snapshot versions of the specified
file or directory.

"""
    elif subcommand == "rollback":
        print """
usage: zhist rollback [options] filename[@snapshot]

Replaces the present version of an object, by a snapshot version.  If @snapshot
is omitted, the most recent snapshot is assumed.

Available options:
    --sure   Will rollback "in-place."  If the rollback fails for some
             reason, the present version will not be preserved.    

"""
    else:
        print "Unknown help option "+str(command)

def cp():
    print "cp"
    sys.exit(0)
def locate():
    print "locate"
    sys.exit(0)
def ls():
    import os,os.path
    if len(sys.argv)<3:
        # Then the person simply did "zhist ls" and the implied target is PWD
        sys.argv.append('.')
    i=2
    while i<len(sys.argv):
        targetgivenname=sys.argv[i]
        targetabsname=os.path.abspath(sys.argv[i])
        if os.path.exists(targetabsname):
            targetinode=os.stat(sys.argv[i])[1]
        else:
            print "'"+str(targetgivenname)+"': No such file or directory"
            i+=1
            break
        print str(targetinode)+" "+str(targetname)
        i+=1        
    sys.exit(0)
def rollback():
    print "rollback"
    sys.exit(0)

def main():
    if len(sys.argv) <= 1:
        usage()
        sys.exit(2)
    if sys.argv[1] == 'cp':
        cp()
        sys.exit(0)
    elif sys.argv[1] == 'help':
        try:
            usage(sys.argv[2])
        except:
            usage()
        sys.exit(2)
    elif sys.argv[1] == 'locate':
        locate()
        sys.exit(0)
    elif sys.argv[1] == 'ls':
        ls()
        sys.exit(0)
    elif sys.argv[1] == 'rollback':
        rollback()
        sys.exit(0)
    else:
        usage()
        sys.exit(2)
    
if __name__ == "__main__":
  sys.exit(main())
